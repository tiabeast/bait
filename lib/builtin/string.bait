package builtin

struct string{
	str &byte
	len i32
}

fun (bp &byte) string_with_len(len int) string {
	return string{
		str: bp
		len: len
	}
}

fun (s string) to_lower()string{
	buf := []byte{len: s.len}
	for i := 0; i < s.len; i += 1 {
		c := s[i]
		if c >= `A` and c <= `Z` {
			buf[i] = c + 32
		} else {
			buf[i] = c
		}
	}
	buf[s.len] = 0
	return buf.str()
}

fun (s string) substr(start i32, end i32) string {
	len := end -start
	if len == s.len {
		return s
	}
	res:=string{
		str:malloc(len+1)
		len:len
	}
	for i := 0; i < len; i+=1{
		res.str[i] = s.str[start + i]
	}
	res.str[len] = 0
	return res
}

fun (s string) split(sep string) []string {
	res := []string
	i := 0
	if sep.len == 0 {
		for i < s.len {
			c := s[i]
			res.push(c.ascii_str())
			i += 1
		}
		return res
	}
	start := 0
	for i < s.len {
		is_sep := i + sep.len <= s.len and s.substr(i, i + sep.len) == sep
		if is_sep {
			val := s.substr(start, i)
			res.push(val)
			start = i + sep.len
			i = start
		} else {
			i += 1
		}
	}
	res.push(s.substr(start, s.len))
	return res
}

fun(s string)contains(substr string)bool{
	if substr.len == 0 {
		return true
	}
	if s.index(substr) == -1 {
		return false
	}
	return true
}

fun (s string) index(substr string) int {
	if substr.len > s.len or substr.len == 0 {
		return -1
	}
	i := 0
	for i < s.len {
		j := 0
		for j < substr.len and s.str[i + j] == substr.str[j] {
			j += 1
		}
		if j == substr.len {
			return i
		}
		i += 1
	}
	return -1
}

fun (s string) at(i i32) byte {
	return s.str[i]
}

fun string_add (a string, b string) string {
	new_len := a.len + b.len
	res := string{
		str: calloc(new_len + 1)
		len: new_len
	}
	for i:=0; i < a.len; i+=1 {
		res.str[i] = a.str[i]
	}
	for i:=0; i < b.len; i+=1 {
		res.str[a.len + i] = b.str[i]
	}
	res.str[new_len] = 0
	return res
}

fun string_eq (a string, b string) bool {
	if a.len != b.len {
		return false
	}
	return C.memcmp(a.str, b.str, a.len) == 0
}
