// This file is part of: bait.
// Copyright (c) 2022 Lukas Neubert.
// Use of this code is governed by an MIT License (see LICENSE.md).
package builtin

struct string{
	str &u8
	len i32
}

fun (bp &u8) string_with_len(len i32) string {
	return string{
		str: bp
		len: len
	}
}

fun (bp &u8) cstring_to_string() string {
	return string{
		str: bp
		len: C.strlen(bp)
	}
}

fun (sp &string) deref() string{
	return string{
		str: sp.str
		len: sp.len
	}
}

fun (s string) to_lower()string{
	buf := []u8{len: s.len}
	for i := 0; i < s.len; i += 1 {
		c := s[i]
		if c >= `A` and c <= `Z` {
			buf[i] = c + 32
		} else {
			buf[i] = c
		}
	}
	buf[s.len] = 0
	return buf.str()
}

fun (s string) substr(start i32, end i32) string {
	len := end -start
	if len == s.len {
		return s
	}
	res:=string{
		str:malloc(len+1)
		len:len
	}
	for i := 0; i < len; i+=1{
		res.str[i] = s.str[start + i]
	}
	res.str[len] = 0
	return res
}

fun (s string) split(sep string) []string {
	res := []string
	i := 0
	if sep.len == 0 {
		for i < s.len {
			c := s[i]
			res.push(c.ascii_str())
			i += 1
		}
		return res
	}
	start := 0
	for i < s.len {
		is_sep := i + sep.len <= s.len and s.substr(i, i + sep.len) == sep
		if is_sep {
			val := s.substr(start, i)
			res.push(val)
			start = i + sep.len
			i = start
		} else {
			i += 1
		}
	}
	res.push(s.substr(start, s.len))
	return res
}

fun (s string) replace(val string, with string) string {
	if s.len == 0 or val.len == 0 or val.len > s.len {
		return s
	}
	idxs := []i32
	i := 0
	for  true {
		i = s.index_after(val, i)
		if i == -1 {
			break
		}
		idxs.push(i)
		i += val.len
	}
	if idxs.len == 0 {
		return s
	}
	new_len := s.len + idxs.len * (with.len - val.len)
	bytes := malloc(new_len + 1)
	bi := 0
	si := 0
	for j := 0; j < idxs.len; j +=1{
		val_pos := idxs[j]
		for si < val_pos {
			bytes[bi] = s[si]
			bi += 1
			si += 1
		}
		si += val.len
		for w := 0; w < with.len; w+=1{
			bytes[bi] = with[w]
			bi += 1
		}
	}
	for si < s.len {
		bytes[bi] = s[si]
		bi += 1
		si += 1
	}
	bytes[new_len] = 0
	return bytes.string_with_len(new_len)
}

fun(s string)contains(substr string)bool{
	if substr.len == 0 {
		return true
	}
	if s.index(substr) > -1 {
		return true
	}
	return false
}

fun (s string) index(substr string) i32 {
	return s.index_after(substr, 0)
}

fun (s string) index_after(substr string, start i32) i32 {
	if substr.len > s.len or substr.len == 0 or start >= s.len {
		return -1
	}
	i := start
	for i < s.len {
		j := 0
		for j < substr.len and s.str[i + j] == substr.str[j] {
			j += 1
		}
		if j == substr.len {
			return i
		}
		i += 1
	}
	return -1
}

fun (s string) index_last(substr string) i32 {
	if substr.len > s.len or substr.len == 0 {
		return -1
	}
	i := s.len - substr.len
	for i >= 0 {
		j := 0
		for j < substr.len and s.str[i + j] == substr.str[j] {
			j += 1
		}
		if j == substr.len {
			return i
		}
		i -= 1
	}
	return -1
}

fun (s string) count (substr string) i32 {
	if s.len == 0 or substr.len == 0 or substr.len > s.len {
		return 0
	}
	n := 0
	i := 0
	for true {
		i = s.index_after(substr, i)
		if i == -1 {
			return n
		}
		i += substr.len
		n += 1
	}
}

fun (s string) at(i i32) u8 {
	return s.str[i]
}

fun string_add (a string, b string) string {
	new_len := a.len + b.len
	res := string{
		str: calloc(new_len + 1)
		len: new_len
	}
	for i:=0; i < a.len; i+=1 {
		res.str[i] = a.str[i]
	}
	for i:=0; i < b.len; i+=1 {
		res.str[a.len + i] = b.str[i]
	}
	res.str[new_len] = 0
	return res
}

fun string_eq (a string, b string) bool {
	if a.len != b.len {
		return false
	}
	return C.memcmp(a.str, b.str, a.len) == 0
}
