// This file is part of: bait programming language
// Copyright (c) 2022 Lukas Neubert
// Use of this code is governed by an MIT License (see LICENSE.md).
package builtin

struct array {
	elem_size i32
	data &void
	len i32
	cap i32
}

fun new_array(len i32, cap i32, elem_size i32) array {
	real_cap := cap
	if cap < len {
		real_cap = len
	}
	return array{
		elem_size: elem_size
		data: calloc(real_cap * elem_size)
		len: len
		cap: real_cap
	}
}

fun new_array_from_c_array(len i32, cap i32, elem_size i32, c_array &void) array {
	real_cap := cap
	if cap < len {
		real_cap = len
	}
	a := array{
		elem_size: elem_size
		data: calloc(real_cap * elem_size)
		len: len
		cap: real_cap
	}
	C.memcpy(a.data, c_array, len * elem_size)
	return a
}

fun (a &array) set(i i32, val &void) {
	C.memcpy(a.data + i * a.elem_size, val, a.elem_size)
}

fun (a array) get(i i32) &void {
	return a.data + i * a.elem_size
}

fun (a &array) ensure_cap(required i32) {
	if required <= a.cap {
		return
	}
	cap := 2
	if a.cap > 0 {
		cap = a.cap
	}
	for required > cap {
		cap *= 2
	}
	new_size := cap * a.elem_size
	new_data := calloc(new_size)
	C.memcpy(new_data, a.data, a.len * a.elem_size)
	a.data = new_data
	a.cap = cap
}

fun (a &array) push(val &void) {
	a.ensure_cap(a.len + 1)
	C.memmove(&byte(a.data) + a.elem_size * a.len, val, a.elem_size)
	a.len += 1
}

fun (a array) slice(start i32, end i32) array {
	data := &byte(a.data) + start * a.elem_size
	len := end - start
	return array{
		elem_size: a.elem_size
		data: data
		len: len
		cap: len
	}
}
